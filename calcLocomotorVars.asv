function [motor_ts, motor_byTrial] = calcLocomotorVars( data, params )

%***For DEVO***
plots.speed = true;

%% Check distance between bodyparts

% Distance from centroid
distance = @(dX,dY) sqrt(sum([dX,dY].^2,2)); %For column vectors dX=X1-X2 and dY=Y1-Y2
objects = ["body","left_ear","right_ear","Scope_1","Scope_2","base_of_tail"];
[posX, posY] = deal(NaN(size(data.DLC.t,1),numel(objects)));

for i = 1:numel(objects) %Aggregate bodypart positions and average
    posX(:,i) = data.DLC.(objects(i)).x;
    posY(:,i) = data.DLC.(objects(i)).y;
end
position.centroid.x = mean(posX,2); 
position.centroid.y = mean(posY,2);

for i = 1:numel(objects) %Take distance from centroid
    dx = data.DLC.(objects(i)).x - position.centroid.x;
    dy = data.DLC.(objects(i)).y - position.centroid.y;
    d_centroid.(objects(i)) = distance(dx,dy); %Euclidean norm recentered on centroid
end
%Plot distance of each bodypart from centroid as f(t)
tiledlayout(numel(objects),1);
for i=1:numel(
plot(


%% Calculate timeseries variables for each tracked object

%Position in cm **requires session-specific scale/transform**

%Speed **in PIX until scaled to cm**
%May require some downsampling to reduce error from tracking jitter (ask Julia)
dt = [0; diff(data.DLC.t)];

%Take average position across spec bodyparts
objects = ["body","base_of_tail"];
[posX, posY] = deal(NaN(size(data.DLC.t,1),numel(objects)));
for i = 1:numel(objects)
    posX(:,i) = data.DLC.(objects(i)).x;
    posY(:,i) = data.DLC.(objects(i)).y;
end
posX = mean(posX,2);
posY = mean(posY,2);

%Calculate speed
dx = [0; diff(posX)]; %Instantaneous change in x,y position
dy = [0; diff(posY)]; 
motor_ts.speed = distance(dx,dy)./dt; %Euclidean distance from last point/dt

%Validation Plots
if plots.speed
    plot(motor_ts.speed);
end

%% Trial-by-Trial Spatial Trajectories

%% Trial-by-Trial Locomotor Variables
%Total Distance traveled
%Also by trial epoch